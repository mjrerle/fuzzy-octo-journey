package edu.csu2017fa314.T29.View;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import edu.csu2017fa314.T29.Model.DistanceCalculator;
import spark.Request;
import spark.Response;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import edu.csu2017fa314.T29.Model.Location;

import static spark.Spark.post;

/**
 * Created by sswensen on 10/1/17.
 */

public class Server {
    ArrayList<Location> destinations;

    public void serve() {
        Gson g = new Gson();
        post("/testing", (rec, res) -> {
            return g.toJson(testing(rec, res));
        });
        post("/download", (rec, res) -> {
            // call the download function
            download(rec, res);
            // return the raw HttpServletResponse from the Response
            // Note that we do not send a JSON
            return rec.raw();
        });
    }

//    private Object queryDatabase(Request rec, Response res) {
//        // Set the return headers
//        setHeaders(res);
//
//        // Init json parser
//        JsonParser parser = new JsonParser();
//
//        // Grab the json body from POST
//        JsonElement elm = parser.parse(rec.body());
//
//        // Create new Gson (a Google library for creating a JSON representation of a java class)
//        Gson gson = new Gson();
//
//        // Create new Object from received JsonElement elm
//        ServerRequest sRec = gson.fromJson(elm, ServerRequest.class);
//
//        // The object generated by the frontend should match whatever class you are reading into.
//        // Notice how DataClass has name and ID and how the frontend is generating an object with name and ID.
//        System.out.println("Got \"" + sRec.toString() + "\" from server.");
//        // Client sends query under "name" field in received json:
//        String searched = sRec.getQuery();
//        // Get something from the server
//        QueryBuilder q = new QueryBuilder("tstroup", "830670870"); // Create new QueryBuilder instance and pass in credentials //TODO update credentials
//        String queryString = "SELECT * FROM airports WHERE municipality LIKE '%" + searched +"%' " + " OR name LIKE '%" + searched +"%' " + " OR type LIKE '%" + searched + "%'";
//        ArrayList<Location> queryResults = q.query(queryString);
//        if(queryResults.size()==0){
//            System.out.println("Size of query results = 0, try a better search");
//            Object err = gson.toJson(new ServerResponse("",0,0,new LinkedList<>(), new Object[0]));
//            //return an empty object json for error handling on the client side
//            return err;
//        }
//        DistanceCalculator dist = new DistanceCalculator(queryResults);
//        LinkedList<Location> itinerary;
//
//        if(sRec.getOpLevel().equals("Nearest Neighbor")){
//           itinerary = dist.computeAllNearestNeighbors();
//        }
//        else{
//            itinerary = dist.computeAllNearestNeighbors();
//            //TODO add change to two_opt method when it is made
//        }
//        SVG svg = new SVG(itinerary);
//
//
//        // Create object with svg file path and array of matching database entries to return to server
//        HashMap<String,String> map = itinerary.get(0).getExtraInfo();
//        Object columns[] = map.keySet().toArray();
//
//        ServerResponse sRes = new ServerResponse(svg.getContents(),svg.getWidth(),svg.getHeight(), itinerary,columns);
//
//        System.out.println("Sending \"" + sRes.toString() + "\" to server.");
//
//        //Convert response to json
//        Object ret = gson.toJson(sRes, ServerResponse.class);
//        /* What to return to the server.
//         * In this example, the "ServerResponse" object sRes is converted into a JSON representation using the GSON library.
//         * If you'd like to see what this JSON looks like, it is logged to the console in the web client.
//         */
//        return ret;
//    }

    private Object download(Request rec, Response res) {
        // As before, parse the request and convert it to a Java class with Gson:
        JsonParser parser = new JsonParser();
        JsonElement elm = parser.parse(rec.body());
        Gson gson = new Gson();
        ServerRequest sRec = gson.fromJson(elm, ServerRequest.class);

        // Sending a file back requires different response headers
        setHeadersFile(res);
        // Write a file to the response
        writeFile(res, sRec.getDescription());

        return res;
    }

    private void writeFile(Response res, ArrayList<String> locations) {
        try {
            // Write our file directly to the response rather than to a file
            PrintWriter fileWriter = new PrintWriter(res.raw().getOutputStream());
            // Ideally, the user will be able to name their own trips. We hard code it here:
            fileWriter.println("{ \"title\" : \"The Coolest Trip\",\n" +
                    "  \"destinations\" : [");
            for (int i = 0; i < locations.size(); i++) {
                if (i < locations.size() - 1) {
                    fileWriter.println("\"" + locations.get(i) + "\",");
                } else {
                    fileWriter.println("\"" + locations.get(i) + "\"]}");
                }
            }
            // Important: flush and close the writer or a blank file will be sent
            fileWriter.flush();
            fileWriter.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private Object testing(Request rec, Response res) {
        setHeaders(res);

        // Init json parser
        JsonParser parser = new JsonParser();

        // Grab the json body from POST
        JsonElement elm = parser.parse(rec.body());

        // Create new Gson (a Google library for creating a JSON representation of a java class)
        Gson gson = new Gson();

        // Create new Object from received JsonElement elm
        // Note that both possible requests have the same format (see app.js)
        ServerRequest sRec = gson.fromJson(elm, ServerRequest.class);

        // The object generated by the frontend should match whatever class you are reading into.
        // Notice how DataClass has name and ID and how the frontend is generating an object with name and ID.
        System.out.println("Got \"" + sRec.toString() + "\" from server.");

        // Because both possible requests from the client have the same format,
        // we can check the "type" of request we've received: either "query" or "svg"
        if (sRec.getRequest().equals("query")) {
            // Set the return headers
            return serveQuery(sRec.getDescription().get(0));
            // if the user uploads a file
        } else if (sRec.getRequest().equals("upload")) {
            return serveUpload(sRec.getDescription());
            // assume if the request is not "query" it is "svg":
        } else {
            return serveSvg(sRec.getDescription().get(0));
        }
    }

    // called by testing method if the client requests an svg
    private Object serveSvg(String opcode) {
        Gson gson = new Gson();
        // Instead of writing the SVG to a file, we send it in plaintext back to the client to be rendered inline
        //assumes that the user has input a query first
        DistanceCalculator distanceCalculator = new DistanceCalculator(destinations);

        LinkedList<Location> locations;
        if(opcode.equals("Nearest Neighbor")) {
            //figure out which method to call... depends on Tim's code
            locations = distanceCalculator.computeAllNearestNeighbors();
        }
        else if(opcode.equals("2-Opt")){
            //what is this method?
            locations = new LinkedList<>();
        }
        else if(opcode.equals("3-Opt")){
            //what is this method?
            locations = new LinkedList<>();
        }
        else{
            //this will most likely be replaced by the global variable destinations once i get SVG to accept an arraylist
            locations = new LinkedList<>();
        }
        SVG svg = new SVG(locations);
        String map = svg.getContents();
        ServerSVGResponse ssres = new ServerSVGResponse((int)svg.getWidth(), (int)svg.getHeight(), map);

        return gson.toJson(ssres, ServerSVGResponse.class);
    }

    // if the user uploads a file
    private Object serveUpload(ArrayList<String> locations) {
        Gson gson = new Gson();

        // Build a query of every code in the destinations file:
        QueryBuilder q = new QueryBuilder("mjrerle", "829975763"); // TODO: replace with credentials
        String queryString = "SELECT * FROM airports WHERE ";
        for (int i = 0; i < locations.size(); i++) {
            if (i == locations.size() - 1) {
                queryString += "code = '" + locations.get(i) + "';";
            } else {
                queryString += "code = '" + locations.get(i) + "' OR ";
            }
        }

        // Query database with queryString
        ArrayList<Location> queryResults = q.query(queryString);

        // Same response structure as the query request
        ServerResponse serverResponse = new ServerResponse(queryResults);
        // set response type to upload
        serverResponse.setResponseType("upload");

        return gson.toJson(serverResponse, ServerResponse.class);
    }

    // called by testing method if client requests a search
    private Object serveQuery(String searched) {
        Gson gson = new Gson();
        QueryBuilder q = new QueryBuilder("mjrerle", "829975763"); // Create new QueryBuilder instance and pass in credentials //TODO update credentials
        String queryString = String.format("SELECT * FROM airports WHERE municipality LIKE '%%%s%%' OR name LIKE '%%%s%%' OR type LIKE '%%%s%%' LIMIT 10", searched, searched, searched);
        ArrayList<Location> queryResults = q.query(queryString);
        if (queryResults.size() == 0) {
            System.out.println("Size of query results = 0, try a better search");
            Object err = gson.toJson(new ServerResponse(null));
            //return an empty object json for error handling on the client side
            return err;
        }
        destinations = new ArrayList<>(queryResults);

        // Create object with svg file path and array of matching database entries to return to server
        HashMap<String,String> map = queryResults.get(0).getExtraInfo();
        Object columns[] = map.keySet().toArray();
        ServerResponse sRes = new ServerResponse(queryResults, columns);
        sRes.setResponseType("query");
        System.out.println("Sending \"" + sRes.toString() + "\" to server.");

        //Convert response to json
        return gson.toJson(sRes, ServerResponse.class);
    }

    private void setHeaders(Response res) {
        // Declares returning type json
        res.header("Content-Type", "application/json");

        // Ok for browser to call even if different host host
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Headers", "*");
    }

    private void setHeadersFile(Response res) {
        /* Unlike the other responses, the file request sends back an actual file. This means
        that we have to work with the raw HttpServletRequest that Spark's Response class is built
        on.
         */
        // First, add the same Access Control headers as before
        res.raw().addHeader("Access-Control-Allow-Origin", "*");
        res.raw().addHeader("Access-Control-Allow-Headers", "*");
        // Set the content type to "force-download." Basically, we "trick" the browser with
        // an unknown file type to make it download the file instead of opening it.
        res.raw().setContentType("application/force-download");
        res.raw().addHeader("Content-Disposition", "attachment; filename=\"selection.json\"");
    }
}